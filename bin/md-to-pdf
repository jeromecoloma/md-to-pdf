#!/bin/bash

# md-to-pdf - Convert markdown files to PDF using pandoc
# A Shell Starter tool for converting markdown documents to PDF format

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_STARTER_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SHELL_STARTER_ROOT}/lib/main.sh"

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_DEPENDENCY_MISSING=1
readonly EXIT_FILE_NOT_FOUND=2
readonly EXIT_PERMISSION_DENIED=3
readonly EXIT_INVALID_FORMAT=4
readonly EXIT_DISK_FULL=5
readonly EXIT_CONVERSION_FAILED=6
readonly EXIT_INTERRUPTED=7

# Global variables for cleanup
TEMP_FILES=()
OUTPUT_FILE=""

# Available themes
readonly AVAILABLE_THEMES=("github" "academic" "clean" "modern")
readonly THEMES_DIR="${SHELL_STARTER_ROOT}/lib/themes"

# Cleanup function for interrupted operations
cleanup() {
	local exit_code=$?
	local interrupted=false

	# Check if we were interrupted
	if [[ $exit_code -eq 130 ]]; then
		interrupted=true
		log::warn "Operation interrupted by user"
	fi

	# Clean up temporary files
	if [[ -n "${TEMP_FILES+x}" ]] && declare -p TEMP_FILES 2>/dev/null | grep -q "declare -a"; then
		for temp_file in "${TEMP_FILES[@]}"; do
			if [[ -f "$temp_file" ]]; then
				rm -f "$temp_file"
				if [[ "$interrupted" == "true" ]]; then
					log::info "Cleaned up temporary file: $temp_file"
				fi
			fi
		done
	fi

	# Clean up partial output file if interrupted
	if [[ "$interrupted" == "true" && -n "$OUTPUT_FILE" && -f "$OUTPUT_FILE" ]]; then
		rm -f "$OUTPUT_FILE"
		log::info "Cleaned up partial output file: $OUTPUT_FILE"
	fi

	# Clean up pandoc error log
	if [[ -f /tmp/pandoc_error.log ]]; then
		rm -f /tmp/pandoc_error.log
	fi

	if [[ "$interrupted" == "true" ]]; then
		log::info "Cleanup completed"
		exit $EXIT_INTERRUPTED
	fi
}

# Set up trap for cleanup on interrupt
trap cleanup INT TERM

show_help() {
	cat <<EOF
Usage: $(basename "$0") [OPTIONS] [INPUT_FILE [OUTPUT_FILE]]

Convert markdown files to PDF using pandoc with theme support.

MODES:
    Interactive Mode:  $(basename "$0")                    # Prompts for all inputs
    Direct Mode:       $(basename "$0") INPUT_FILE         # Convert with defaults

ARGUMENTS:
    INPUT_FILE         Path to the markdown file to convert
    OUTPUT_FILE        Optional output PDF file path (default: INPUT_FILE.pdf)

OPTIONS:
    -h, --help         Show this help message and exit
    -v, --version      Show version information and exit
    -q, --quiet        Suppress verbose output
    -f, --force        Overwrite existing output files without prompting
    -t, --theme THEME  Use specified theme (default: github)
    -l, --list-themes  List available themes and exit
    -p, --preview      Show conversion preview without creating PDF
    -c, --css FILE     Use custom CSS file for styling

THEMES:
    github             GitHub-style formatting (default)
    academic           Academic paper formatting
    clean              Clean, minimal formatting
    modern             Modern, professional formatting

EXAMPLES:
    $(basename "$0")                           # Interactive mode
    $(basename "$0") document.md               # Convert to document.pdf
    $(basename "$0") document.md report.pdf    # Convert to report.pdf
    $(basename "$0") --theme academic doc.md   # Use academic theme
    $(basename "$0") --css custom.css doc.md   # Use custom CSS
    $(basename "$0") --preview document.md     # Preview conversion
    $(basename "$0") --list-themes             # Show available themes
    $(basename "$0") --force document.md       # Overwrite existing document.pdf
    $(basename "$0") --help                    # Show this help
EOF
}

check_dependencies() {
	local missing_deps=()

	if ! command -v pandoc >/dev/null 2>&1; then
		missing_deps+=("pandoc")
	fi

	if [[ ${#missing_deps[@]} -gt 0 ]]; then
		log::error "Required dependencies missing: ${missing_deps[*]}"
		log::info "Please install the missing dependencies:"
		log::info ""
		log::info "macOS (Homebrew):"
		log::info "  brew install pandoc"
		log::info ""
		log::info "Ubuntu/Debian:"
		log::info "  sudo apt-get update && sudo apt-get install -y pandoc"
		log::info ""
		log::info "Other Linux distributions:"
		log::info "  Check your package manager for pandoc"
		log::info ""
		log::info "Or download from: https://pandoc.org/installing.html"
		return 1
	fi

	return 0
}

validate_file_permissions() {
	local input_file="$1"
	local output_file="$2"

	# Check if input file exists and is readable
	if [[ ! -r "$input_file" ]]; then
		log::error "Cannot read input file: $input_file"
		if [[ ! -e "$input_file" ]]; then
			log::error "File does not exist"
			return $EXIT_FILE_NOT_FOUND
		else
			log::error "File exists but is not readable (check permissions)"
			return $EXIT_PERMISSION_DENIED
		fi
	fi

	# Check if input file is actually a markdown file
	if [[ ! "$input_file" =~ \.(md|markdown)$ ]]; then
		log::warn "Input file does not have .md or .markdown extension: $input_file"
		log::warn "Proceeding anyway, but ensure it's valid markdown"
	fi

	# Check output file permissions
	local output_dir
	if [[ -n "$output_file" ]]; then
		output_dir="$(dirname "$output_file")"
	else
		output_dir="$(dirname "$input_file")"
	fi

	if [[ ! -w "$output_dir" ]]; then
		log::error "Cannot write to output directory: $output_dir"
		log::error "Check directory permissions"
		return $EXIT_PERMISSION_DENIED
	fi

	return 0
}

check_output_file_exists() {
	local output_file="$1"
	local quiet="$2"
	local force="$3"

	if [[ -f "$output_file" ]]; then
		if [[ "$force" == "true" ]]; then
			# Force mode - overwrite without prompting
			if [[ "$quiet" == "false" ]]; then
				log::warn "Overwriting existing file: $output_file"
			fi
			return 0
		elif [[ "$quiet" == "true" ]]; then
			# Quiet mode - warn but don't prompt
			log::warn "Output file already exists and will be overwritten: $output_file"
			return 0
		else
			# Interactive mode - prompt for confirmation
			log::warn "Output file already exists: $output_file"
			read -p "Do you want to overwrite it? (y/N): " -n 1 -r
			echo
			if [[ ! $REPLY =~ ^[Yy]$ ]]; then
				log::info "Operation cancelled by user"
				return 1
			fi
		fi
	fi

	return 0
}

check_disk_space() {
	local output_file="$1"
	local input_file="$2"

	# Get output directory
	local output_dir
	if [[ -n "$output_file" ]]; then
		output_dir="$(dirname "$output_file")"
	else
		output_dir="$(dirname "$input_file")"
	fi

	# Get available disk space in MB
	local available_space
	if command -v df >/dev/null 2>&1; then
		available_space=$(df -m "$output_dir" | tail -1 | awk '{print $4}')
	else
		# Fallback if df not available
		available_space=1000 # Assume 1GB available
	fi

	# Estimate output size (rough estimate: input size * 2 + 100KB overhead)
	local input_size
	if [[ -f "$input_file" ]]; then
		input_size=$(stat -f%z "$input_file" 2>/dev/null || stat -c%s "$input_file" 2>/dev/null || echo "1000")
		input_size=$((input_size / 1024 / 1024)) # Convert to MB
	else
		input_size=1
	fi

	local estimated_output=$((input_size * 2 + 1)) # 2x input + 1MB overhead

	if [[ $available_space -lt $estimated_output ]]; then
		log::error "Insufficient disk space for conversion"
		log::error "Available: ${available_space}MB, Estimated needed: ${estimated_output}MB"
		log::error "Please free up disk space or choose a different output location"
		return $EXIT_DISK_FULL
	fi

	return 0
}

validate_markdown_format() {
	local input_file="$1"

	# Check if file is empty
	if [[ ! -s "$input_file" ]]; then
		log::error "Input file is empty: $input_file"
		log::error "Please provide a markdown file with content"
		return $EXIT_INVALID_FORMAT
	fi

	# Basic validation - check for common markdown patterns
	local has_markdown=false
	local line_count=0

	while IFS= read -r line || [[ -n "$line" ]]; do
		((line_count++))
		# Check for markdown headers, links, lists, etc.
		if [[ $line =~ ^#{1,6}\  ]] || [[ $line =~ \[.*\]\(.*\) ]] || [[ $line =~ ^[\*\-\+]\  ]] || [[ $line =~ ^[0-9]+\.\  ]]; then
			has_markdown=true
			break
		fi

		# Limit check to first 10 lines for performance
		if [[ $line_count -gt 10 ]]; then
			break
		fi
	done <"$input_file"

	if [[ "$has_markdown" == "false" ]]; then
		log::warn "Input file does not appear to contain markdown formatting"
		log::warn "Proceeding with conversion anyway..."
	fi

	return 0
}

validate_theme() {
	local theme="$1"

	# Check if theme is in available themes
	for available_theme in "${AVAILABLE_THEMES[@]}"; do
		if [[ "$theme" == "$available_theme" ]]; then
			return 0
		fi
	done

	log::error "Invalid theme: $theme"
	log::info "Available themes:"
	for available_theme in "${AVAILABLE_THEMES[@]}"; do
		log::info "  - $available_theme"
	done
	return 1
}

list_themes() {
	log::info "Available themes:"
	for theme in "${AVAILABLE_THEMES[@]}"; do
		log::info "  - $theme"
	done
}

validate_css_file() {
	local css_file="$1"

	if [[ -z "$css_file" ]]; then
		return 0
	fi

	if [[ ! -f "$css_file" ]]; then
		log::error "CSS file not found: $css_file"
		return 1
	fi

	if [[ ! -r "$css_file" ]]; then
		log::error "CSS file is not readable: $css_file"
		return 1
	fi

	# Basic CSS validation - check if it contains CSS-like content
	if ! grep -q "{" "$css_file" 2>/dev/null; then
		log::warn "CSS file does not appear to contain valid CSS rules: $css_file"
		log::warn "Proceeding anyway..."
	fi

	return 0
}

show_preview() {
	local input_file="$1"
	local output_file="$2"
	local theme="$3"
	local css_file="$4"

	log::info "=== CONVERSION PREVIEW ==="
	log::info "Input file: $input_file"

	# Get file information
	if [[ -f "$input_file" ]]; then
		local file_size
		file_size=$(stat -f%z "$input_file" 2>/dev/null || stat -c%s "$input_file" 2>/dev/null || echo "unknown")
		local line_count
		line_count=$(wc -l <"$input_file" 2>/dev/null || echo "unknown")
		log::info "File size: ${file_size} bytes"
		log::info "Line count: ${line_count} lines"
	else
		log::info "File status: Not found (will be created if conversion proceeds)"
	fi

	log::info "Output file: $output_file"
	log::info "Selected theme: $theme"

	# Show theme template information
	local theme_tex="${THEMES_DIR}/${theme}.tex"
	if [[ -f "$theme_tex" ]]; then
		log::info "Theme template: $theme_tex (found)"
	else
		log::info "Theme template: $theme_tex (not found - will use default)"
	fi

	# Show CSS information if specified
	if [[ -n "$css_file" ]]; then
		if [[ -f "$css_file" ]]; then
			log::info "Custom CSS: $css_file (found)"
		else
			log::info "Custom CSS: $css_file (not found)"
		fi
	fi

	# Show pandoc command that would be executed
	local pandoc_cmd="pandoc \"$input_file\" -o \"$output_file\" --pdf-engine=xelatex"
	if [[ -f "$theme_tex" ]]; then
		pandoc_cmd="$pandoc_cmd --template \"$theme_tex\""
	fi
	if [[ -n "$css_file" ]]; then
		pandoc_cmd="$pandoc_cmd --css \"$css_file\""
	fi

	log::info "Pandoc command: $pandoc_cmd"
	log::info ""
	log::info "To proceed with conversion, remove the --preview flag"
	log::info "To change theme, use --theme <theme_name>"
	log::info "To change output file, specify it as second argument"
}

convert_markdown_to_pdf() {
	local input_file="$1"
	local output_file="$2"
	local quiet="$3"
	local theme="$4"
	local css_file="$5"

	if [[ "$quiet" == "false" ]]; then
		log::info "Starting markdown to PDF conversion..."
		log::info "Using theme: $theme"
		spinner::start "Converting $input_file to PDF with $theme theme"
	fi

	# Track temporary files for cleanup
	TEMP_FILES+=("/tmp/pandoc_error.log")

	# Build pandoc command with theme support
	local pandoc_cmd="pandoc \"$input_file\" -o \"$output_file\" --pdf-engine=xelatex"

	# Add theme template if theme file exists
	local theme_tex="${THEMES_DIR}/${theme}.tex"

	if [[ -f "$theme_tex" ]]; then
		pandoc_cmd="$pandoc_cmd --template \"$theme_tex\""
	else
		log::warn "Theme template not found: $theme_tex - using default pandoc template"
	fi

	# Add custom CSS if specified (primarily for HTML output, but included for completeness)
	if [[ -n "$css_file" ]]; then
		pandoc_cmd="$pandoc_cmd --css \"$css_file\""
		if [[ "$quiet" == "false" ]]; then
			log::info "Using custom CSS: $css_file"
		fi
	fi

	# Execute pandoc command
	if eval "$pandoc_cmd" 2>/tmp/pandoc_error.log; then
		if [[ "$quiet" == "false" ]]; then
			spinner::stop
			log::success "Conversion completed successfully"
			log::info "Output saved to: $output_file"
		fi
		return $EXIT_SUCCESS
	else
		local exit_code=$?
		if [[ "$quiet" == "false" ]]; then
			spinner::stop
		fi

		log::error "Pandoc conversion failed (exit code: $exit_code)"

		# Check if error log has useful information
		if [[ -s /tmp/pandoc_error.log ]]; then
			log::error "Pandoc error details:"
			cat /tmp/pandoc_error.log >&2
		fi

		# Provide specific guidance based on common errors
		if [[ $exit_code -eq 127 ]]; then
			log::error "Pandoc command not found. Please ensure pandoc is installed."
			return $EXIT_DEPENDENCY_MISSING
		elif [[ $exit_code -eq 47 ]]; then
			log::error "PDF engine (xelatex) not found. Install LaTeX distribution:"
			log::error "  macOS: brew install mactex"
			log::error "  Ubuntu: sudo apt-get install texlive-xetex"
			return $EXIT_DEPENDENCY_MISSING
		else
			log::error "Conversion failed. Check input file format and try again."
			return $EXIT_CONVERSION_FAILED
		fi
	fi
}

validate_conversion_result() {
	local output_file="$1"

	if [[ ! -f "$output_file" ]]; then
		log::error "Output file was not created: $output_file"
		return 1
	fi

	if [[ ! -s "$output_file" ]]; then
		log::error "Output file is empty: $output_file"
		return 1
	fi

	# Basic PDF validation - check if it starts with PDF header
	if ! head -c 4 "$output_file" | grep -q "%PDF"; then
		log::error "Output file does not appear to be a valid PDF: $output_file"
		return 1
	fi

	return 0
}

prompt_theme_selection() {
	local current_theme="$1"

	log::info "Available themes:"
	local i=1
	for theme in "${AVAILABLE_THEMES[@]}"; do
		if [[ "$theme" == "$current_theme" ]]; then
			log::info "  $i. $theme (current default)"
		else
			log::info "  $i. $theme"
		fi
		((i++))
	done

	log::info ""
	read -p "Select theme (1-${#AVAILABLE_THEMES[@]}, or press Enter for default '$current_theme'): " -r theme_choice
	echo

	if [[ -z "$theme_choice" ]]; then
		echo "$current_theme"
		return 0
	fi

	# Validate numeric input
	if ! [[ "$theme_choice" =~ ^[0-9]+$ ]]; then
		log::error "Invalid input: please enter a number between 1 and ${#AVAILABLE_THEMES[@]}"
		return 1
	fi

	# Check range
	if [[ $theme_choice -lt 1 || $theme_choice -gt ${#AVAILABLE_THEMES[@]} ]]; then
		log::error "Invalid choice: please select a number between 1 and ${#AVAILABLE_THEMES[@]}"
		return 1
	fi

	# Get theme name (arrays are 0-indexed)
	local selected_theme="${AVAILABLE_THEMES[$((theme_choice - 1))]}"
	log::info "Selected theme: $selected_theme"
	echo "$selected_theme"
}

interactive_mode() {
	local input_file=""
	local output_file=""
	local theme="github"
	local css_file=""
	local force=false

	# Initialize temporary files array for cleanup
	TEMP_FILES=()

	log::info "=== INTERACTIVE MODE ==="
	log::info "Welcome to md-to-pdf! Let's convert your markdown file to PDF."
	log::info ""

	# Prompt for input file
	while [[ -z "$input_file" ]]; do
		read -p "Enter path to markdown file: " -r input_file
		echo

		if [[ -z "$input_file" ]]; then
			log::warn "Input file is required. Please try again."
			continue
		fi

		# Validate input file
		if [[ ! -r "$input_file" ]]; then
			if [[ ! -e "$input_file" ]]; then
				log::error "File does not exist: $input_file"
			else
				log::error "File is not readable: $input_file"
			fi
			input_file=""
			continue
		fi

		# Check file extension
		if [[ ! "$input_file" =~ \.(md|markdown)$ ]]; then
			log::warn "File does not have .md or .markdown extension: $input_file"
			read -p "Continue anyway? (y/N): " -n 1 -r
			echo
			if [[ ! $REPLY =~ ^[Yy]$ ]]; then
				input_file=""
				continue
			fi
		fi
	done

	# Set default output file
	local default_output="${input_file%.*}.pdf"
	read -p "Enter output PDF file path (default: $default_output): " -r output_file
	echo

	if [[ -z "$output_file" ]]; then
		output_file="$default_output"
	fi

	# Check if output file exists
	if [[ -f "$output_file" ]]; then
		log::warn "Output file already exists: $output_file"
		read -p "Overwrite it? (y/N): " -n 1 -r
		echo
		if [[ $REPLY =~ ^[Yy]$ ]]; then
			force=true
		else
			log::info "Operation cancelled"
			return 1
		fi
	fi

	# Prompt for theme selection
	local selected_theme
	selected_theme=$(prompt_theme_selection "$theme")
	local prompt_result=$?

	if [[ $prompt_result -ne 0 ]]; then
		log::error "Theme selection failed"
		return 1
	fi

	theme=$(echo "$selected_theme" | tr -d '\n\r')

	# Optional: prompt for custom CSS
	read -p "Enter custom CSS file path (optional, press Enter to skip): " -r css_file
	echo

	if [[ -n "$css_file" ]]; then
		if ! validate_css_file "$css_file"; then
			log::warn "CSS file validation failed, proceeding without custom CSS"
			css_file=""
		fi
	fi

	# Show summary and confirm
	log::info "=== CONVERSION SUMMARY ==="
	log::info "Input file: $input_file"
	log::info "Output file: $output_file"
	log::info "Theme: $theme"
	if [[ -n "$css_file" ]]; then
		log::info "Custom CSS: $css_file"
	fi
	log::info ""

	read -p "Proceed with conversion? (Y/n): " -n 1 -r
	echo

	if [[ $REPLY =~ ^[Nn]$ ]]; then
		log::info "Operation cancelled by user"
		return 1
	fi

	# Perform validation checks
	log::info "Validating input..."

	# Validate file permissions
	validate_file_permissions "$input_file" "$output_file"
	local validation_result=$?
	if [[ $validation_result -ne 0 ]]; then
		return $validation_result
	fi

	# Validate markdown format
	validate_markdown_format "$input_file"
	local format_result=$?
	if [[ $format_result -ne 0 ]]; then
		return $format_result
	fi

	# Check disk space
	check_disk_space "$input_file" "$output_file"
	local disk_result=$?
	if [[ $disk_result -ne 0 ]]; then
		return $disk_result
	fi

	# Perform the conversion
	log::info "Starting conversion..."
	local conversion_result
	conversion_result=$(convert_markdown_to_pdf "$input_file" "$output_file" "false" "$theme" "$css_file")
	local conversion_exit=$?

	if [[ $conversion_exit -ne $EXIT_SUCCESS ]]; then
		return $conversion_exit
	fi

	# Validate the result
	if ! validate_conversion_result "$output_file"; then
		log::error "Output validation failed"
		return $EXIT_CONVERSION_FAILED
	fi

	log::success "Interactive conversion completed successfully!"
	log::info "Output saved to: $output_file"

	return $EXIT_SUCCESS
}

main() {
	local quiet=false
	local force=false
	local theme="github"
	local preview=false
	local css_file=""
	local input_file=""
	local output_file=""

	# Check dependencies first
	if ! check_dependencies; then
		exit $EXIT_DEPENDENCY_MISSING
	fi

	while [[ $# -gt 0 ]]; do
		case $1 in
		--quiet | -q)
			quiet=true
			shift
			;;
		--force | -f)
			force=true
			shift
			;;
		--theme | -t)
			if [[ -z "$2" || "$2" =~ ^- ]]; then
				log::error "Theme name is required after --theme/-t"
				echo "Use --help for usage information."
				exit 1
			fi
			theme="$2"
			shift 2
			;;
		--list-themes | -l)
			list_themes
			exit $EXIT_SUCCESS
			;;
		--preview | -p)
			preview=true
			shift
			;;
		--css | -c)
			if [[ -z "$2" || "$2" =~ ^- ]]; then
				log::error "CSS file path is required after --css/-c"
				echo "Use --help for usage information."
				exit 1
			fi
			css_file="$2"
			shift 2
			;;
		--help | -h | --version | -v)
			parse_common_args "$(basename "$0")" "$@"
			;;
		-*)
			log::error "Unknown option: $1"
			echo "Use --help for usage information."
			exit 1
			;;
		*)
			if [[ -z "$input_file" ]]; then
				input_file="$1"
			elif [[ -z "$output_file" ]]; then
				output_file="$1"
			else
				log::error "Too many arguments"
				echo "Use --help for usage information."
				exit 1
			fi
			shift
			;;
		esac
	done

	# Validate theme
	if ! validate_theme "$theme"; then
		exit 1
	fi

	# Validate CSS file if specified
	if ! validate_css_file "$css_file"; then
		exit 1
	fi

	# Check if we should enter interactive mode
	if [[ -z "$input_file" && $# -eq 0 ]]; then
		# No arguments provided, enter interactive mode
		interactive_mode
		exit $?
	fi

	if [[ -z "$input_file" ]]; then
		log::error "Input file is required"
		echo "Use --help for usage information."
		exit 1
	fi

	# Handle preview mode
	if [[ "$preview" == "true" ]]; then
		# Set default output file for preview
		if [[ -z "$output_file" ]]; then
			output_file="${input_file%.*}.pdf"
		fi
		show_preview "$input_file" "$output_file" "$theme" "$css_file"
		exit $EXIT_SUCCESS
	fi

	# Set default output file if not specified
	if [[ -z "$output_file" ]]; then
		output_file="${input_file%.*}.pdf"
	fi

	# Check if output file already exists
	if ! check_output_file_exists "$output_file" "$quiet" "$force"; then
		exit $EXIT_SUCCESS # User cancelled, not an error
	fi

	# Validate file permissions and paths
	validate_file_permissions "$input_file" "$output_file"
	local validation_result=$?
	if [[ $validation_result -ne 0 ]]; then
		exit $validation_result
	fi

	# Validate markdown format
	validate_markdown_format "$input_file"
	local format_result=$?
	if [[ $format_result -ne 0 ]]; then
		exit $format_result
	fi

	# Check disk space
	check_disk_space "$input_file" "$output_file"
	local disk_result=$?
	if [[ $disk_result -ne 0 ]]; then
		exit $disk_result
	fi

	# Set global output file for cleanup
	OUTPUT_FILE="$output_file"

	if [[ "$quiet" == "false" ]]; then
		log::info "md-to-pdf tool initialized"
		log::info "Input file: $input_file"
		log::info "Output file: $output_file"
	fi

	# Perform the conversion
	local conversion_result
	conversion_result=$(convert_markdown_to_pdf "$input_file" "$output_file" "$quiet" "$theme" "$css_file")
	local conversion_exit=$?

	if [[ $conversion_exit -ne $EXIT_SUCCESS ]]; then
		exit $conversion_exit
	fi

	# Validate the result
	if ! validate_conversion_result "$output_file"; then
		log::error "Output validation failed"
		exit $EXIT_CONVERSION_FAILED
	fi

	if [[ "$quiet" == "false" ]]; then
		log::success "md-to-pdf conversion completed successfully!"
	fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
