#!/bin/bash

# md-to-pdf - Convert markdown files to PDF using pandoc
# A Shell Starter tool for converting markdown documents to PDF format

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_STARTER_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SHELL_STARTER_ROOT}/lib/main.sh"

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_DEPENDENCY_MISSING=1
readonly EXIT_FILE_NOT_FOUND=2
readonly EXIT_PERMISSION_DENIED=3
readonly EXIT_INVALID_FORMAT=4
readonly EXIT_DISK_FULL=5
readonly EXIT_CONVERSION_FAILED=6
readonly EXIT_INTERRUPTED=7

# Global variables for cleanup
TEMP_FILES=()
OUTPUT_FILE=""

# Available themes
readonly AVAILABLE_THEMES=("github" "academic" "clean" "modern")
readonly THEMES_DIR="${SHELL_STARTER_ROOT}/lib/themes"

# Available PDF engines
readonly AVAILABLE_ENGINES=("weasyprint" "xelatex")
readonly DEFAULT_ENGINE="weasyprint"

# Cleanup function for interrupted operations
cleanup() {
	local exit_code=$?
	local interrupted=false

	# Check if we were interrupted (SIGINT = 130 or direct signal trap)
	if [[ $exit_code -eq 130 ]] || [[ "$1" == "INT" ]]; then
		interrupted=true
		log::info "Operation interrupted by user (Ctrl+C)"
	fi

	# Clean up temporary files
	if [[ -n "${TEMP_FILES+x}" ]] && declare -p TEMP_FILES 2>/dev/null | grep -q "declare -a"; then
		for temp_file in "${TEMP_FILES[@]}"; do
			if [[ -f "$temp_file" ]]; then
				rm -f "$temp_file"
				if [[ "$interrupted" == "true" ]]; then
					log::info "Cleaned up temporary file: $temp_file"
				fi
			fi
		done
	fi

	# Clean up partial output file if interrupted
	if [[ "$interrupted" == "true" && -n "$OUTPUT_FILE" && -f "$OUTPUT_FILE" ]]; then
		rm -f "$OUTPUT_FILE"
		log::info "Cleaned up partial output file: $OUTPUT_FILE"
	fi

	# Clean up pandoc error log
	if [[ -f /tmp/pandoc_error.log ]]; then
		rm -f /tmp/pandoc_error.log
	fi

	if [[ "$interrupted" == "true" ]]; then
		echo "" # Add newline after ^C
		log::info "Exiting..."
		exit $EXIT_INTERRUPTED
	fi
}

# Set up trap for cleanup on interrupt
trap 'cleanup INT' INT
trap 'cleanup TERM' TERM

show_help() {
	cat <<EOF
Usage: $(basename "$0") [OPTIONS] [INPUT_FILE [OUTPUT_FILE]]

Convert markdown files to PDF using pandoc with theme support.

MODES:
    Interactive Mode:  $(basename "$0")                    # Prompts for all inputs
    Direct Mode:       $(basename "$0") INPUT_FILE         # Convert with defaults

ARGUMENTS:
    INPUT_FILE         Path to the markdown file to convert
    OUTPUT_FILE        Optional output PDF file path (default: INPUT_FILE.pdf)

OPTIONS:
    -h, --help         Show this help message and exit
    -v, --version      Show version information and exit
    -q, --quiet        Suppress verbose output
    -f, --force        Overwrite existing output files without prompting
    -t, --theme THEME  Use specified theme (default: github)
    -l, --list-themes  List available themes and exit
    -p, --preview      Show conversion preview without creating PDF
    -c, --css FILE     Use custom CSS file for styling
    -e, --engine ENGINE Use specified PDF engine (default: auto-select)
    --list-engines     List available PDF engines and exit
    --update           Check for and install the latest version from GitHub
    --uninstall        Uninstall md-to-pdf and remove all installed files (downloads robust uninstaller)

ENGINES:
    weasyprint         Enhanced CSS rendering with full emoji support and theme optimization (preferred)
    xelatex           LaTeX-based PDF generation for complex math content (fallback)

THEMES:
    github             Authentic GitHub-style markdown rendering with emoji support (default)
    academic           Formal academic paper formatting with structured layout
    clean              Clean, minimal design with readable typography
    modern             Contemporary WeasyPrint-optimized styling with clean gradients

EXAMPLES:
    $(basename "$0")                           # Interactive mode
    $(basename "$0") document.md               # Convert to document.pdf
    $(basename "$0") document.md report.pdf    # Convert to report.pdf
    $(basename "$0") --theme github doc.md     # Use GitHub theme with emoji support
    $(basename "$0") --theme modern doc.md     # Use WeasyPrint-optimized modern theme
    $(basename "$0") --css custom.css doc.md   # Use custom CSS
    $(basename "$0") --preview document.md     # Preview conversion
    $(basename "$0") --list-themes             # Show available themes
    $(basename "$0") --list-engines           # Show available PDF engines
    $(basename "$0") --engine weasyprint doc.md # Force WeasyPrint engine (recommended)
    $(basename "$0") --engine xelatex doc.md   # Force XeLaTeX engine
    $(basename "$0") --force document.md       # Overwrite existing document.pdf
    $(basename "$0") --update                  # Update to the latest version
    $(basename "$0") --uninstall               # Uninstall md-to-pdf (downloads latest uninstaller)
    $(basename "$0") --help                    # Show this help
EOF
}

update_to_latest_version() {
	log::info "Checking for updates to md-to-pdf..."

	# Get current version
	local current_version
	current_version=$(get_version)
	log::info "Current version: $current_version"

	# Check for internet connectivity and curl
	if ! command -v curl >/dev/null 2>&1; then
		log::error "curl is required for updates but is not installed"
		log::info "Please install curl and try again, or update manually from:"
		log::info "  https://github.com/jeromecoloma/md-to-pdf"
		return 1
	fi

	# Fetch latest release info from GitHub API
	log::info "Fetching latest version information..."
	local github_api_url="https://api.github.com/repos/jeromecoloma/md-to-pdf/releases/latest"
	local latest_info

	if ! latest_info=$(curl -fsSL --connect-timeout 10 --max-time 30 "$github_api_url" 2>/tmp/update_error.log); then
		log::error "Failed to fetch latest version information from GitHub"
		if [[ -s /tmp/update_error.log ]]; then
			log::error "Error details:"
			cat /tmp/update_error.log >&2
		fi
		log::info "You can manually check for updates at:"
		log::info "  https://github.com/jeromecoloma/md-to-pdf/releases"
		return 1
	fi

	# Extract latest version using basic text processing (avoiding jq dependency)
	local latest_version
	latest_version=$(echo "$latest_info" | grep '"tag_name"' | head -1 | sed 's/.*"tag_name": *"\([^"]*\)".*/\1/' | sed 's/^v//')

	if [[ -z "$latest_version" ]]; then
		log::error "Could not parse latest version from GitHub API response"
		log::info "You can manually check for updates at:"
		log::info "  https://github.com/jeromecoloma/md-to-pdf/releases"
		return 1
	fi

	log::info "Latest version: $latest_version"

	# Compare versions (simple string comparison should work for semver)
	if [[ "$current_version" == "$latest_version" ]]; then
		log::success "You are already running the latest version ($current_version)"
		return 0
	fi

	# Check if current version is newer (in case user has a development version)
	if [[ "$current_version" > "$latest_version" ]]; then
		log::info "You appear to be running a development version ($current_version)"
		log::info "Latest stable release is: $latest_version"
		read -p "Do you want to downgrade to the latest stable release? (y/N): " -n 1 -r
		echo
		if [[ ! $REPLY =~ ^[Yy]$ ]]; then
			log::info "Update cancelled"
			return 0
		fi
	else
		# Normal case: current < latest
		log::info "Update available: $current_version â†’ $latest_version"

		# Show release notes if available
		local release_notes
		release_notes=$(echo "$latest_info" | grep -A 1000 '"body"' | head -1 | sed 's/.*"body": *"\(.*\)",/\1/' | sed 's/\\n/\n/g' | sed 's/\\"/"/g')
		if [[ -n "$release_notes" && "$release_notes" != "null" ]]; then
			log::info ""
			log::info "Release notes:"
			echo "$release_notes" | head -10  # Show first 10 lines
			log::info ""
		fi

		read -p "Do you want to update to version $latest_version? (Y/n): " -n 1 -r
		echo
		if [[ $REPLY =~ ^[Nn]$ ]]; then
			log::info "Update cancelled"
			return 0
		fi
	fi

	# Proceed with update
	log::info "Downloading and running the latest installer..."

	local installer_url="https://raw.githubusercontent.com/jeromecoloma/md-to-pdf/main/install.sh"

	# Test if we can reach the installer URL
	if ! curl -fsSL --connect-timeout 10 --max-time 5 "$installer_url" >/dev/null 2>&1; then
		log::error "Cannot download installer from GitHub"
		log::info "Please try updating manually:"
		log::info "  bash <(curl -fsSL https://raw.githubusercontent.com/jeromecoloma/md-to-pdf/main/install.sh)"
		return 1
	fi

	# Download and execute installer
	log::info "Installing version $latest_version..."
	if bash <(curl -fsSL --connect-timeout 10 --max-time 60 "$installer_url") 2>/dev/null; then
		log::success "Update completed successfully!"

		# Verify the update
		local new_version
		new_version=$(get_version)
		if [[ "$new_version" == "$latest_version" ]]; then
			log::success "Successfully updated from $current_version to $new_version"
		else
			log::warn "Update completed but version check shows: $new_version"
			log::info "This might be normal if the installer is still running"
		fi

		log::info "You may need to restart your shell or run 'source ~/.bashrc' (or similar)"
		log::info "to use the updated version in new terminal sessions"

		exit $EXIT_SUCCESS
	else
		log::error "Update failed during installation"
		log::info "Please try manually:"
		log::info "  bash <(curl -fsSL https://raw.githubusercontent.com/jeromecoloma/md-to-pdf/main/install.sh)"
		return 1
	fi
}

uninstall_md_to_pdf() {
	# Built-in fallback uninstaller (simpler version of standalone uninstall.sh)
	# Used when the robust standalone uninstaller cannot be downloaded
	local manifest_dir="$HOME/.config/md-to-pdf"
	local manifest_file="$manifest_dir/install-manifest.txt"

	log::info "Starting md-to-pdf uninstallation (built-in uninstaller)..."

	# Check if manifest exists
	if [[ ! -f "$manifest_file" ]]; then
		log::error "Installation manifest not found: $manifest_file"
		log::error "This tool may not have been installed via the installer script."
		log::info "To manually uninstall:"
		log::info "1. Remove the md-to-pdf binary from your PATH"
		log::info "2. Remove the ~/.config/md-to-pdf directory"
		return 1
	fi

	log::info "Found installation manifest: $manifest_file"

	# Show what will be removed
	local files_to_remove=()
	while IFS= read -r line; do
		# Skip comments and empty lines
		[[ -z "$line" || "$line" =~ ^# ]] && continue
		if [[ -e "$line" ]]; then
			files_to_remove+=("$line")
		fi
	done <"$manifest_file"

	if [[ ${#files_to_remove[@]} -eq 0 ]]; then
		log::warn "No files found to remove"
	else
		log::info "Files to be removed:"
		for file in "${files_to_remove[@]}"; do
			log::info "  - $file"
		done
	fi

	# Get confirmation
	echo
	if ! read -p "Do you want to proceed with uninstallation? (y/N): " -n 1 -r; then
		echo "" # Add newline after ^C
		log::info "Uninstallation cancelled"
		exit $EXIT_INTERRUPTED
	fi
	echo
	if [[ ! $REPLY =~ ^[Yy]$ ]]; then
		log::info "Uninstallation cancelled"
		return 0
	fi

	# Remove files
	local removed_count=0
	for file_path in "${files_to_remove[@]}"; do
		if [[ -f "$file_path" ]]; then
			if rm "$file_path"; then
				log::info "Removed: $file_path"
				((removed_count++))
			else
				log::error "Failed to remove: $file_path"
			fi
		elif [[ -d "$file_path" ]]; then
			if rmdir "$file_path" 2>/dev/null; then
				log::info "Removed directory: $file_path"
				((removed_count++))
			else
				log::info "Directory not empty, skipping: $file_path"
			fi
		fi
	done

	# Get install prefix from manifest
	local install_prefix=""
	while IFS= read -r line; do
		if [[ "$line" =~ ^#.*Install\ prefix:\ (.+)$ ]]; then
			install_prefix="${BASH_REMATCH[1]}"
			break
		fi
	done <"$manifest_file"

	# Remove PATH entry from shell config if we found the prefix
	if [[ -n "$install_prefix" ]]; then
		local shell_config
		case "$(basename "$SHELL")" in
		zsh) shell_config="$HOME/.zshrc" ;;
		bash)
			if [[ -f "$HOME/.bashrc" ]]; then
				shell_config="$HOME/.bashrc"
			else
				shell_config="$HOME/.bash_profile"
			fi
			;;
		fish) shell_config="$HOME/.config/fish/config.fish" ;;
		*) shell_config="$HOME/.bashrc" ;;
		esac

		if [[ -f "$shell_config" ]] && grep -q "export PATH.*$install_prefix" "$shell_config"; then
			log::info "Removing PATH entry from $shell_config"
			local temp_file
			temp_file=$(mktemp)
			local skip_next=false

			while IFS= read -r line; do
				if [[ "$skip_next" == "true" ]]; then
					skip_next=false
					continue
				fi

				if [[ "$line" == "# Added by md-to-pdf installer" ]]; then
					skip_next=true
					continue
				fi

				if [[ "$line" == "export PATH=\"$install_prefix:\$PATH\"" ]]; then
					continue
				fi

				echo "$line" >>"$temp_file"
			done <"$shell_config"

			if mv "$temp_file" "$shell_config"; then
				log::info "PATH entry removed from $shell_config"
			else
				log::error "Failed to update $shell_config"
			fi
		fi
	fi

	# Remove manifest and config directory
	if rm "$manifest_file" 2>/dev/null; then
		log::info "Removed manifest: $manifest_file"
	fi

	if rmdir "$manifest_dir" 2>/dev/null; then
		log::info "Removed config directory: $manifest_dir"
	fi

	log::success "Uninstallation complete!"
	log::info "Removed $removed_count files/directories"
	if [[ -n "${shell_config:-}" ]]; then
		log::info "Please run 'source $shell_config' or restart your shell for PATH changes to take effect"
	fi

	exit $EXIT_SUCCESS
}

check_dependencies() {
	local missing_deps=()

	if ! command -v pandoc >/dev/null 2>&1; then
		missing_deps+=("pandoc")
	fi

	if [[ ${#missing_deps[@]} -gt 0 ]]; then
		log::error "Required dependencies missing: ${missing_deps[*]}"
		log::info "Please install the missing dependencies:"
		log::info ""
		log::info "macOS (Homebrew):"
		log::info "  brew install pandoc"
		log::info ""
		log::info "Ubuntu/Debian:"
		log::info "  sudo apt-get update && sudo apt-get install -y pandoc"
		log::info ""
		log::info "Other Linux distributions:"
		log::info "  Check your package manager for pandoc"
		log::info ""
		log::info "Or download from: https://pandoc.org/installing.html"
		return 1
	fi

	return 0
}

check_weasyprint() {
	if command -v weasyprint >/dev/null 2>&1; then
		return 0
	fi
	return 1
}

get_weasyprint_version() {
	if check_weasyprint; then
		weasyprint --version 2>/dev/null | grep -o '[0-9][0-9.]*' | head -1
	else
		echo "not installed"
	fi
}

prompt_weasyprint_installation() {
	log::info "WeasyPrint is not installed but provides enhanced PDF rendering with CSS support."
	log::info "Would you like to install WeasyPrint automatically? (recommended)"
	log::info ""
	log::info "WeasyPrint benefits:"
	log::info "  - Better CSS-based styling (especially GitHub theme)"
	log::info "  - Improved emoji and Unicode support"
	log::info "  - Modern web-style layout rendering"
	log::info ""
	read -r -p "Install WeasyPrint now? [Y/n]: " response
	case $response in
	[nN][oO] | [nN])
		log::info "Skipping WeasyPrint installation. Using XeLaTeX fallback."
		return 1
		;;
	*)
		return 0
		;;
	esac
}

install_weasyprint() {
	log::info "Installing WeasyPrint (this may take a few minutes)..."

	# Detect system and use appropriate package manager
	local install_success=false

	if command -v brew >/dev/null 2>&1; then
		log::info "Using Homebrew to install WeasyPrint..."
		if brew install weasyprint 2>/tmp/weasyprint_install.log; then
			log::success "WeasyPrint installed successfully via Homebrew"
			install_success=true
		else
			log::error "Homebrew installation failed"
			if [[ -s /tmp/weasyprint_install.log ]]; then
				log::error "Installation error details:"
				cat /tmp/weasyprint_install.log >&2
			fi
		fi
	elif command -v pip3 >/dev/null 2>&1; then
		log::info "Using pip3 to install WeasyPrint..."
		# Try with system dependencies first
		if pip3 install weasyprint 2>/tmp/weasyprint_install.log; then
			log::success "WeasyPrint installed successfully via pip3"
			install_success=true
		else
			log::error "pip3 installation failed"
			if [[ -s /tmp/weasyprint_install.log ]]; then
				log::error "Installation error details:"
				cat /tmp/weasyprint_install.log >&2

				# Check for common pip installation issues
				if grep -q "No module named" /tmp/weasyprint_install.log 2>/dev/null; then
					log::info "This might be a dependency issue. Try installing system packages first:"
					if command -v apt-get >/dev/null 2>&1; then
						log::info "  sudo apt-get install python3-dev python3-pip python3-setuptools python3-wheel"
					elif command -v yum >/dev/null 2>&1; then
						log::info "  sudo yum install python3-devel python3-pip python3-setuptools python3-wheel"
					fi
				fi
			fi
		fi
	elif command -v apt-get >/dev/null 2>&1; then
		log::info "Using apt-get to install WeasyPrint..."
		if sudo apt-get update 2>/tmp/weasyprint_install.log && sudo apt-get install -y python3-weasyprint 2>>/tmp/weasyprint_install.log; then
			log::success "WeasyPrint installed successfully via apt-get"
			install_success=true
		else
			log::error "apt-get installation failed"
			if [[ -s /tmp/weasyprint_install.log ]]; then
				log::error "Installation error details:"
				cat /tmp/weasyprint_install.log >&2
			fi
		fi
	elif command -v yum >/dev/null 2>&1; then
		log::info "Using yum to install WeasyPrint..."
		if sudo yum install -y python3-weasyprint 2>/tmp/weasyprint_install.log; then
			log::success "WeasyPrint installed successfully via yum"
			install_success=true
		else
			log::error "yum installation failed"
			if [[ -s /tmp/weasyprint_install.log ]]; then
				log::error "Installation error details:"
				cat /tmp/weasyprint_install.log >&2
			fi
		fi
	else
		log::error "No supported package manager found (brew, pip3, apt-get, or yum)"
	fi

	# Verify installation if it reported success
	if [[ "$install_success" == "true" ]]; then
		if check_weasyprint; then
			log::info "WeasyPrint installation verified successfully"
			return 0
		else
			log::error "Installation completed but WeasyPrint is not working properly"
			install_success=false
		fi
	fi

	# Installation failed - provide comprehensive manual installation guidance
	if [[ "$install_success" == "false" ]]; then
		log::error "Automatic installation failed. Please install WeasyPrint manually:"
		log::info ""
		log::info "ðŸ“¦ Method 1 - pip3 (recommended for most users):"
		log::info "  pip3 install weasyprint"
		log::info ""
		log::info "ðŸ“¦ Method 2 - System package manager:"
		if command -v brew >/dev/null 2>&1; then
			log::info "  macOS: brew install weasyprint"
		elif command -v apt-get >/dev/null 2>&1; then
			log::info "  Ubuntu/Debian: sudo apt-get install python3-weasyprint"
		elif command -v yum >/dev/null 2>&1; then
			log::info "  CentOS/RHEL: sudo yum install python3-weasyprint"
		fi
		log::info ""
		log::info "ðŸ“¦ Method 3 - From source (if other methods fail):"
		log::info "  pip3 install --upgrade pip setuptools wheel"
		log::info "  pip3 install weasyprint"
		log::info ""
		log::info "ðŸ”§ System dependencies (may be required):"
		if command -v apt-get >/dev/null 2>&1; then
			log::info "  Ubuntu/Debian: sudo apt-get install build-essential python3-dev python3-pip python3-setuptools"
		elif command -v yum >/dev/null 2>&1; then
			log::info "  CentOS/RHEL: sudo yum groupinstall 'Development Tools' && sudo yum install python3-devel"
		fi
		log::info ""
		log::info "ðŸ“– For more help, visit: https://doc.courtbouillon.org/weasyprint/stable/first_steps.html"
		log::info ""
		log::info "After manual installation, run this tool again to use WeasyPrint."
	fi

	return 1
}

select_engine() {
	local preferred_engine="$1"

	# If user specified an engine, validate and use it
	if [[ -n "$preferred_engine" ]]; then
		if validate_engine "$preferred_engine"; then
			echo "$preferred_engine"
			return 0
		else
			log::error "Invalid engine: $preferred_engine"
			list_engines
			return 1
		fi
	fi

	# Auto-select best available engine (WeasyPrint first)
	for engine in "${AVAILABLE_ENGINES[@]}"; do
		if engine_available "$engine"; then
			echo "$engine"
			return 0
		fi
	done

	log::error "No PDF engines available"
	return 1
}

validate_engine() {
	local engine="$1"

	# Check if engine is in available list
	for available_engine in "${AVAILABLE_ENGINES[@]}"; do
		if [[ "$engine" == "$available_engine" ]]; then
			return 0
		fi
	done

	return 1
}

engine_available() {
	local engine="$1"

	case "$engine" in
	"weasyprint")
		check_weasyprint
		;;
	"xelatex")
		command -v xelatex >/dev/null 2>&1
		;;
	*)
		return 1
		;;
	esac
}

list_engines() {
	log::info "Available PDF engines:"
	for engine in "${AVAILABLE_ENGINES[@]}"; do
		local status="available"
		if ! engine_available "$engine"; then
			status="not installed"
		fi

		case "$engine" in
		"weasyprint")
			local version=$(get_weasyprint_version)
			log::info "  - $engine ($status) - Enhanced CSS rendering, emoji support"
			if [[ "$version" != "not installed" ]]; then
				log::info "    Version: $version"
			fi
			;;
		"xelatex")
			log::info "  - $engine ($status) - LaTeX-based PDF generation (fallback)"
			;;
		esac
	done
}

validate_file_permissions() {
	local input_file="$1"
	local output_file="$2"

	# Check if input file exists and is readable
	if [[ ! -r "$input_file" ]]; then
		log::error "Cannot read input file: $input_file"
		if [[ ! -e "$input_file" ]]; then
			log::error "File does not exist"
			return $EXIT_FILE_NOT_FOUND
		else
			log::error "File exists but is not readable (check permissions)"
			return $EXIT_PERMISSION_DENIED
		fi
	fi

	# Check if input file is actually a markdown file
	if [[ ! "$input_file" =~ \.(md|markdown)$ ]]; then
		log::warn "Input file does not have .md or .markdown extension: $input_file"
		log::warn "Proceeding anyway, but ensure it's valid markdown"
	fi

	# Check output file permissions
	local output_dir
	if [[ -n "$output_file" ]]; then
		output_dir="$(dirname "$output_file")"
	else
		output_dir="$(dirname "$input_file")"
	fi

	if [[ ! -w "$output_dir" ]]; then
		log::error "Cannot write to output directory: $output_dir"
		log::error "Check directory permissions"
		return $EXIT_PERMISSION_DENIED
	fi

	return 0
}

check_output_file_exists() {
	local output_file="$1"
	local quiet="$2"
	local force="$3"

	if [[ -f "$output_file" ]]; then
		if [[ "$force" == "true" ]]; then
			# Force mode - overwrite without prompting
			if [[ "$quiet" == "false" ]]; then
				log::warn "Overwriting existing file: $output_file"
			fi
			return 0
		elif [[ "$quiet" == "true" ]]; then
			# Quiet mode - warn but don't prompt
			log::warn "Output file already exists and will be overwritten: $output_file"
			return 0
		else
			# Interactive mode - prompt for confirmation
			log::warn "Output file already exists: $output_file"
			read -p "Do you want to overwrite it? (y/N): " -n 1 -r
			echo
			if [[ ! $REPLY =~ ^[Yy]$ ]]; then
				log::info "Operation cancelled by user"
				return 1
			fi
		fi
	fi

	return 0
}

check_disk_space() {
	local output_file="$1"
	local input_file="$2"

	# Get output directory
	local output_dir
	if [[ -n "$output_file" ]]; then
		output_dir="$(dirname "$output_file")"
	else
		output_dir="$(dirname "$input_file")"
	fi

	# Get available disk space in MB
	local available_space
	if command -v df >/dev/null 2>&1; then
		available_space=$(df -m "$output_dir" | tail -1 | awk '{print $4}')
	else
		# Fallback if df not available
		available_space=1000 # Assume 1GB available
	fi

	# Estimate output size (rough estimate: input size * 2 + 100KB overhead)
	local input_size
	if [[ -f "$input_file" ]]; then
		input_size=$(stat -f%z "$input_file" 2>/dev/null || stat -c%s "$input_file" 2>/dev/null || echo "1000")
		input_size=$((input_size / 1024 / 1024)) # Convert to MB
	else
		input_size=1
	fi

	local estimated_output=$((input_size * 2 + 1)) # 2x input + 1MB overhead

	if [[ $available_space -lt $estimated_output ]]; then
		log::error "Insufficient disk space for conversion"
		log::error "Available: ${available_space}MB, Estimated needed: ${estimated_output}MB"
		log::error "Please free up disk space or choose a different output location"
		return $EXIT_DISK_FULL
	fi

	return 0
}

validate_markdown_format() {
	local input_file="$1"

	# Check if file is empty
	if [[ ! -s "$input_file" ]]; then
		log::error "Input file is empty: $input_file"
		log::error "Please provide a markdown file with content"
		return $EXIT_INVALID_FORMAT
	fi

	# Basic validation - check for common markdown patterns
	local has_markdown=false
	local line_count=0

	while IFS= read -r line || [[ -n "$line" ]]; do
		((line_count++))
		# Check for markdown headers, links, lists, etc.
		if [[ $line =~ ^#{1,6}\  ]] || [[ $line =~ \[.*\]\(.*\) ]] || [[ $line =~ ^[\*\-\+]\  ]] || [[ $line =~ ^[0-9]+\.\  ]]; then
			has_markdown=true
			break
		fi

		# Limit check to first 10 lines for performance
		if [[ $line_count -gt 10 ]]; then
			break
		fi
	done <"$input_file"

	if [[ "$has_markdown" == "false" ]]; then
		log::warn "Input file does not appear to contain markdown formatting"
		log::warn "Proceeding with conversion anyway..."
	fi

	return 0
}

validate_theme() {
	local theme="$1"

	# Check if theme is in available themes
	for available_theme in "${AVAILABLE_THEMES[@]}"; do
		if [[ "$theme" == "$available_theme" ]]; then
			return 0
		fi
	done

	log::error "Invalid theme: $theme"
	log::info "Available themes:"
	for available_theme in "${AVAILABLE_THEMES[@]}"; do
		log::info "  - $available_theme"
	done
	return 1
}

list_themes() {
	log::info "Available themes:"
	for theme in "${AVAILABLE_THEMES[@]}"; do
		log::info "  - $theme"
	done
}

validate_css_file() {
	local css_file="$1"

	if [[ -z "$css_file" ]]; then
		return 0
	fi

	if [[ ! -f "$css_file" ]]; then
		log::error "CSS file not found: $css_file"
		return 1
	fi

	if [[ ! -r "$css_file" ]]; then
		log::error "CSS file is not readable: $css_file"
		return 1
	fi

	# Basic CSS validation - check if it contains CSS-like content
	if ! grep -q "{" "$css_file" 2>/dev/null; then
		log::warn "CSS file does not appear to contain valid CSS rules: $css_file"
		log::warn "Proceeding anyway..."
	fi

	return 0
}

show_preview() {
	local input_file="$1"
	local output_file="$2"
	local theme="$3"
	local css_file="$4"
	local engine="$5"

	log::info "=== CONVERSION PREVIEW ==="
	log::info "Input file: $input_file"

	# Get file information
	if [[ -f "$input_file" ]]; then
		local file_size
		file_size=$(stat -f%z "$input_file" 2>/dev/null || stat -c%s "$input_file" 2>/dev/null || echo "unknown")
		local line_count
		line_count=$(wc -l <"$input_file" 2>/dev/null || echo "unknown")
		log::info "File size: ${file_size} bytes"
		log::info "Line count: ${line_count} lines"
	else
		log::info "File status: Not found (will be created if conversion proceeds)"
	fi

	log::info "Output file: $output_file"
	log::info "Selected theme: $theme"
	log::info "Selected engine: $engine"

	# Show engine status
	if engine_available "$engine"; then
		log::info "Engine status: $engine (available)"
	else
		log::info "Engine status: $engine (not available)"
	fi

	# Show engine-specific template information
	case "$engine" in
	"weasyprint")
		local theme_css="${THEMES_DIR}/${theme}.css"
		if [[ -f "$theme_css" ]]; then
			log::info "Theme CSS: $theme_css (found)"
		else
			log::info "Theme CSS: $theme_css (not found - will use default)"
		fi
		;;
	"xelatex")
		local theme_tex="${THEMES_DIR}/${theme}.tex"
		if [[ -f "$theme_tex" ]]; then
			log::info "Theme template: $theme_tex (found)"
		else
			log::info "Theme template: $theme_tex (not found - will use default)"
		fi
		;;
	esac

	# Show CSS information if specified
	if [[ -n "$css_file" ]]; then
		if [[ -f "$css_file" ]]; then
			log::info "Custom CSS: $css_file (found)"
		else
			log::info "Custom CSS: $css_file (not found)"
		fi
	fi

	# Show conversion commands that would be executed
	case "$engine" in
	"weasyprint")
		local temp_html="/tmp/md-to-pdf-preview.html"
		local pandoc_cmd="pandoc \"$input_file\" -o \"$temp_html\" -t html --standalone --metadata title=\"\" --from markdown+emoji+task_lists+strikeout+superscript+subscript"
		local theme_css="${THEMES_DIR}/${theme}.css"
		if [[ -f "$theme_css" ]]; then
			pandoc_cmd="$pandoc_cmd --css \"$theme_css\""
		fi
		if [[ -n "$css_file" ]]; then
			pandoc_cmd="$pandoc_cmd --css \"$css_file\""
		fi
		log::info "Pandoc HTML command: $pandoc_cmd"
		log::info "WeasyPrint command: weasyprint \"$temp_html\" \"$output_file\""
		;;
	"xelatex")
		local pandoc_cmd="pandoc \"$input_file\" -o \"$output_file\" --pdf-engine=xelatex"
		local theme_tex="${THEMES_DIR}/${theme}.tex"
		if [[ -f "$theme_tex" ]]; then
			pandoc_cmd="$pandoc_cmd --template \"$theme_tex\""
		fi
		log::info "Pandoc command: $pandoc_cmd"
		if [[ -n "$css_file" ]]; then
			log::info "Note: Custom CSS is not directly supported with XeLaTeX engine"
		fi
		;;
	esac
	log::info ""
	log::info "To proceed with conversion, remove the --preview flag"
	log::info "To change theme, use --theme <theme_name>"
	log::info "To change output file, specify it as second argument"
}

convert_markdown_to_pdf() {
	local input_file="$1"
	local output_file="$2"
	local quiet="$3"
	local theme="$4"
	local css_file="$5"
	local engine="$6"

	if [[ "$quiet" == "false" ]]; then
		log::info "Starting markdown to PDF conversion..."
		log::info "Using theme: $theme"
		log::info "Using engine: $engine"
		spinner::start "Converting $input_file to PDF with $theme theme using $engine"
	fi

	# Track temporary files for cleanup
	TEMP_FILES+=("/tmp/pandoc_error.log")

	# Engine-specific conversion with enhanced error handling
	case "$engine" in
	"weasyprint")
		if ! convert_with_weasyprint "$input_file" "$output_file" "$theme" "$css_file" "$quiet"; then
			local weasyprint_exit=$?

			# If WeasyPrint failed and we're in non-interactive mode, offer fallback
			if [[ "$quiet" == "false" ]]; then
				spinner::stop
				log::warn "WeasyPrint conversion failed, but XeLaTeX is available as fallback."

				# Only offer fallback if XeLaTeX is available
				if engine_available "xelatex"; then
					log::info "Would you like to retry with XeLaTeX engine?"
					read -p "Retry with XeLaTeX? [Y/n]: " -n 1 -r
					echo
					if [[ ! $REPLY =~ ^[Nn]$ ]]; then
						log::info "Retrying with XeLaTeX engine..."
						spinner::start "Converting $input_file to PDF with $theme theme using xelatex"
						if convert_with_xelatex "$input_file" "$output_file" "$theme" "$css_file" "$quiet"; then
							log::success "Conversion succeeded with XeLaTeX fallback!"
							return $EXIT_SUCCESS
						else
							log::error "XeLaTeX fallback also failed."
							return $EXIT_CONVERSION_FAILED
						fi
					fi
				else
					log::error "XeLaTeX is also not available. Please install LaTeX distribution."
					log::info "macOS: brew install mactex"
					log::info "Ubuntu: sudo apt-get install texlive-xetex"
				fi
			fi

			return $weasyprint_exit
		fi
		;;
	"xelatex")
		convert_with_xelatex "$input_file" "$output_file" "$theme" "$css_file" "$quiet"
		;;
	*)
		if [[ "$quiet" == "false" ]]; then
			spinner::stop
		fi
		log::error "Unsupported engine: $engine"
		return $EXIT_CONVERSION_FAILED
		;;
	esac
}

convert_with_weasyprint() {
	local input_file="$1"
	local output_file="$2"
	local theme="$3"
	local css_file="$4"
	local quiet="$5"

	# Create temporary HTML file
	local temp_html="/tmp/md-to-pdf-$$.html"
	TEMP_FILES+=("$temp_html")

	# Build pandoc command for HTML output with enhanced emoji and GitHub support
	local pandoc_cmd="pandoc \"$input_file\" -o \"$temp_html\" -t html --standalone --metadata title=\"\" --from markdown+emoji+task_lists+strikeout+superscript+subscript"

	# Add CSS theme
	local theme_css="${THEMES_DIR}/${theme}.css"
	if [[ -f "$theme_css" ]]; then
		pandoc_cmd="$pandoc_cmd --css \"$theme_css\""
	fi

	# Add custom CSS if specified
	if [[ -n "$css_file" ]]; then
		pandoc_cmd="$pandoc_cmd --css \"$css_file\""
		if [[ "$quiet" == "false" ]]; then
			log::info "Using custom CSS: $css_file"
		fi
	fi

	# Convert markdown to HTML
	if ! eval "$pandoc_cmd" 2>/tmp/pandoc_error.log; then
		local exit_code=$?
		if [[ "$quiet" == "false" ]]; then
			spinner::stop
		fi
		log::error "Pandoc HTML conversion failed (exit code: $exit_code)"

		# Provide specific guidance for pandoc errors
		if [[ -s /tmp/pandoc_error.log ]]; then
			log::error "Pandoc error details:"
			cat /tmp/pandoc_error.log >&2
		fi

		log::error "This error occurred during HTML generation for WeasyPrint."
		log::error "Try using XeLaTeX engine instead: --engine xelatex"
		return $EXIT_CONVERSION_FAILED
	fi

	# Convert HTML to PDF with WeasyPrint
	if weasyprint "$temp_html" "$output_file" 2>/tmp/weasyprint_error.log; then
		if [[ "$quiet" == "false" ]]; then
			spinner::stop
			log::success "Conversion completed successfully"
			log::info "Output saved to: $output_file"
		fi
		return $EXIT_SUCCESS
	else
		local exit_code=$?
		if [[ "$quiet" == "false" ]]; then
			spinner::stop
		fi
		log::error "WeasyPrint conversion failed (exit code: $exit_code)"

		# Analyze WeasyPrint error for specific guidance
		local error_message=""
		if [[ -s /tmp/weasyprint_error.log ]]; then
			error_message=$(cat /tmp/weasyprint_error.log)
			log::error "WeasyPrint error details:"
			echo "$error_message" >&2
		fi

		# Provide specific error handling and recovery options
		case $exit_code in
		127)
			# Command not found
			log::error "WeasyPrint command not found. This is unexpected since we checked availability."
			log::error "Please reinstall WeasyPrint or use XeLaTeX engine: --engine xelatex"
			;;
		1)
			# General error - check for common issues
			if echo "$error_message" | grep -qi "gtk\|glib\|cairo\|pango"; then
				log::error "WeasyPrint dependency issue detected (GTK/Cairo/Pango)."
				log::error "This usually requires system-level dependencies."
				log::info "Try reinstalling WeasyPrint with system dependencies:"
				log::info "  pip3 install --force-reinstall weasyprint"
				log::info "Or use XeLaTeX engine: --engine xelatex"
			elif echo "$error_message" | grep -qi "css\|stylesheet"; then
				log::error "CSS parsing error detected."
				log::error "Check your custom CSS file or try without CSS: remove --css option"
				log::info "Or use XeLaTeX engine: --engine xelatex"
			else
				log::error "WeasyPrint encountered an unknown error."
				log::error "This might be due to HTML complexity or system configuration."
				log::info "Try using XeLaTeX engine as fallback: --engine xelatex"
			fi
			;;
		*)
			# Other exit codes
			log::error "WeasyPrint failed with exit code $exit_code."
			log::info "Try using XeLaTeX engine as fallback: --engine xelatex"
			;;
		esac

		# Offer automatic fallback to XeLaTeX
		if [[ "$quiet" == "false" ]]; then
			log::info ""
			log::info "Would you like to automatically retry with XeLaTeX engine? (recommended)"
			read -p "Retry with XeLaTeX? [Y/n]: " -n 1 -r
			echo
			if [[ ! $REPLY =~ ^[Nn]$ ]]; then
				log::info "Retrying conversion with XeLaTeX engine..."
				# Call XeLaTeX conversion with same parameters
				if convert_with_xelatex "$input_file" "$output_file" "$theme" "$css_file" "$quiet"; then
					log::success "Conversion succeeded with XeLaTeX fallback!"
					return $EXIT_SUCCESS
				else
					log::error "XeLaTeX fallback also failed."
					return $EXIT_CONVERSION_FAILED
				fi
			fi
		fi

		return $EXIT_CONVERSION_FAILED
	fi
}

convert_with_xelatex() {
	local input_file="$1"
	local output_file="$2"
	local theme="$3"
	local css_file="$4"
	local quiet="$5"

	# Build pandoc command with XeLaTeX
	local pandoc_cmd="pandoc \"$input_file\" -o \"$output_file\" --pdf-engine=xelatex"

	# Add theme template if theme file exists
	local theme_tex="${THEMES_DIR}/${theme}.tex"
	if [[ -f "$theme_tex" ]]; then
		pandoc_cmd="$pandoc_cmd --template \"$theme_tex\""
	else
		if [[ "$quiet" == "false" ]]; then
			log::warn "Theme template not found: $theme_tex - using default pandoc template"
		fi
	fi

	# Add custom CSS if specified (for reference, though XeLaTeX doesn't use CSS directly)
	if [[ -n "$css_file" && "$quiet" == "false" ]]; then
		log::info "Note: Custom CSS is not directly supported with XeLaTeX engine"
	fi

	# Execute pandoc command
	if eval "$pandoc_cmd" 2>/tmp/pandoc_error.log; then
		if [[ "$quiet" == "false" ]]; then
			spinner::stop
			log::success "Conversion completed successfully"
			log::info "Output saved to: $output_file"
		fi
		return $EXIT_SUCCESS
	else
		local exit_code=$?
		if [[ "$quiet" == "false" ]]; then
			spinner::stop
		fi
		log::error "Pandoc conversion failed (exit code: $exit_code)"

		# Check if error log has useful information
		if [[ -s /tmp/pandoc_error.log ]]; then
			log::error "Pandoc error details:"
			cat /tmp/pandoc_error.log >&2
		fi

		# Provide specific guidance based on common errors
		if [[ $exit_code -eq 127 ]]; then
			log::error "Pandoc command not found. Please ensure pandoc is installed."
			return $EXIT_DEPENDENCY_MISSING
		elif [[ $exit_code -eq 47 ]]; then
			log::error "PDF engine (xelatex) not found. Install LaTeX distribution:"
			log::error "  macOS: brew install mactex"
			log::error "  Ubuntu: sudo apt-get install texlive-xetex"
			return $EXIT_DEPENDENCY_MISSING
		else
			log::error "Conversion failed. Check input file format and try again."
			return $EXIT_CONVERSION_FAILED
		fi
	fi
}

validate_conversion_result() {
	local output_file="$1"

	if [[ ! -f "$output_file" ]]; then
		log::error "Output file was not created: $output_file"
		return 1
	fi

	if [[ ! -s "$output_file" ]]; then
		log::error "Output file is empty: $output_file"
		return 1
	fi

	# Basic PDF validation - check if it starts with PDF header
	if ! head -c 4 "$output_file" | grep -q "%PDF"; then
		log::error "Output file does not appear to be a valid PDF: $output_file"
		return 1
	fi

	return 0
}

prompt_theme_selection() {
	local current_theme="$1"

	log::info "Available themes:"
	local i=1
	for theme in "${AVAILABLE_THEMES[@]}"; do
		if [[ "$theme" == "$current_theme" ]]; then
			log::info "  $i. $theme (current default)"
		else
			log::info "  $i. $theme"
		fi
		((i++))
	done

	log::info ""
	if ! read -p "Select theme (1-${#AVAILABLE_THEMES[@]}, or press Enter for default '$current_theme'): " -r theme_choice; then
		echo "" # Add newline after ^C
		log::info "Exiting interactive mode..."
		exit $EXIT_INTERRUPTED
	fi
	echo

	if [[ -z "$theme_choice" ]]; then
		echo "$current_theme"
		return 0
	fi

	# Validate numeric input
	if ! [[ "$theme_choice" =~ ^[0-9]+$ ]]; then
		log::error "Invalid input: please enter a number between 1 and ${#AVAILABLE_THEMES[@]}"
		return 1
	fi

	# Check range
	if [[ $theme_choice -lt 1 || $theme_choice -gt ${#AVAILABLE_THEMES[@]} ]]; then
		log::error "Invalid choice: please select a number between 1 and ${#AVAILABLE_THEMES[@]}"
		return 1
	fi

	# Get theme name (arrays are 0-indexed)
	local selected_theme="${AVAILABLE_THEMES[$((theme_choice - 1))]}"
	log::info "Selected theme: $selected_theme"
	echo "$selected_theme"
}

prompt_engine_selection() {
	local current_engine="$1"

	log::info "Available PDF engines:"
	local i=1
	for engine in "${AVAILABLE_ENGINES[@]}"; do
		local status="not available"
		if engine_available "$engine"; then
			status="available"
		fi

		local description=""
		case "$engine" in
		"weasyprint")
			description=" - Enhanced CSS rendering, emoji support"
			;;
		"xelatex")
			description=" - LaTeX-based PDF generation (fallback)"
			;;
		esac

		if [[ "$engine" == "$current_engine" ]]; then
			log::info "  $i. $engine ($status)$description (current default)"
		else
			log::info "  $i. $engine ($status)$description"
		fi
		((i++))
	done

	log::info ""
	if ! read -p "Select PDF engine (1-${#AVAILABLE_ENGINES[@]}, or press Enter for auto-selection): " -r engine_choice; then
		echo "" # Add newline after ^C
		log::info "Exiting interactive mode..."
		exit $EXIT_INTERRUPTED
	fi
	echo

	if [[ -z "$engine_choice" ]]; then
		# Auto-select best available engine
		local auto_engine
		if auto_engine=$(select_engine ""); then
			log::info "Auto-selected engine: $auto_engine"
			echo "$auto_engine"
			return 0
		else
			log::error "Auto-selection failed"
			return 1
		fi
	fi

	# Validate numeric input
	if ! [[ "$engine_choice" =~ ^[0-9]+$ ]]; then
		log::error "Invalid input: please enter a number between 1 and ${#AVAILABLE_ENGINES[@]}"
		return 1
	fi

	# Check range
	if [[ $engine_choice -lt 1 || $engine_choice -gt ${#AVAILABLE_ENGINES[@]} ]]; then
		log::error "Invalid choice: please select a number between 1 and ${#AVAILABLE_ENGINES[@]}"
		return 1
	fi

	# Get engine name (arrays are 0-indexed)
	local selected_engine="${AVAILABLE_ENGINES[$((engine_choice - 1))]}"

	# Validate that selected engine is available
	if ! engine_available "$selected_engine"; then
		log::error "Selected engine is not available: $selected_engine"
		list_engines
		return 1
	fi

	log::info "Selected engine: $selected_engine"
	echo "$selected_engine"
}

interactive_mode() {
	local input_file=""
	local output_file=""
	local theme="github"
	local css_file=""
	local force=false
	local engine=""

	# Initialize temporary files array for cleanup
	TEMP_FILES=()

	log::info "=== INTERACTIVE MODE ==="
	log::info "Welcome to md-to-pdf! Let's convert your markdown file to PDF."
	log::info "Type 'exit', 'quit', or 'q' at any prompt to exit, or press Ctrl+C"
	log::info ""

	# Prompt for input file
	while [[ -z "$input_file" ]]; do
		if ! read -p "Enter path to markdown file (or 'exit' to quit): " -r input_file; then
			echo "" # Add newline after ^C
			log::info "Exiting interactive mode..."
			exit $EXIT_INTERRUPTED
		fi
		echo

		if [[ -z "$input_file" ]]; then
			log::warn "Input file is required. Please try again."
			continue
		fi

		# Check for exit commands
		if [[ "$input_file" == "exit" || "$input_file" == "quit" || "$input_file" == "q" ]]; then
			log::info "Exiting interactive mode..."
			exit $EXIT_SUCCESS
		fi

		# Validate input file
		if [[ ! -r "$input_file" ]]; then
			if [[ ! -e "$input_file" ]]; then
				log::error "File does not exist: $input_file"
			else
				log::error "File is not readable: $input_file"
			fi
			input_file=""
			continue
		fi

		# Check file extension
		if [[ ! "$input_file" =~ \.(md|markdown)$ ]]; then
			log::warn "File does not have .md or .markdown extension: $input_file"
			if ! read -p "Continue anyway? (y/N): " -n 1 -r; then
				echo "" # Add newline after ^C
				log::info "Exiting interactive mode..."
				exit $EXIT_INTERRUPTED
			fi
			echo
			if [[ ! $REPLY =~ ^[Yy]$ ]]; then
				input_file=""
				continue
			fi
		fi
	done

	# Set default output file
	local default_output="${input_file%.*}.pdf"
	if ! read -p "Enter output PDF file path (default: $default_output, or 'exit' to quit): " -r output_file; then
		echo "" # Add newline after ^C
		log::info "Exiting interactive mode..."
		exit $EXIT_INTERRUPTED
	fi
	echo

	# Check for exit commands
	if [[ "$output_file" == "exit" || "$output_file" == "quit" || "$output_file" == "q" ]]; then
		log::info "Exiting interactive mode..."
		exit $EXIT_SUCCESS
	fi

	if [[ -z "$output_file" ]]; then
		output_file="$default_output"
	fi

	# Check if output file exists
	if [[ -f "$output_file" ]]; then
		log::warn "Output file already exists: $output_file"
		if ! read -p "Overwrite it? (y/N): " -n 1 -r; then
			echo "" # Add newline after ^C
			log::info "Exiting interactive mode..."
			exit $EXIT_INTERRUPTED
		fi
		echo
		if [[ $REPLY =~ ^[Yy]$ ]]; then
			force=true
		else
			log::info "Operation cancelled"
			return 1
		fi
	fi

	# Prompt for theme selection
	local selected_theme
	selected_theme=$(prompt_theme_selection "$theme")
	local prompt_result=$?

	if [[ $prompt_result -ne 0 ]]; then
		log::error "Theme selection failed"
		return 1
	fi

	theme=$(echo "$selected_theme" | tr -d '\n\r')

	# Prompt for engine selection
	local selected_engine
	selected_engine=$(prompt_engine_selection "$DEFAULT_ENGINE")
	local engine_result=$?
	if [[ $engine_result -ne 0 ]]; then
		log::error "Engine selection failed"
		return 1
	fi
	engine="$selected_engine"

	# Handle WeasyPrint auto-installation if not available
	if [[ "$engine" == "weasyprint" ]] && ! check_weasyprint; then
		if prompt_weasyprint_installation; then
			if install_weasyprint; then
				log::info "WeasyPrint installed successfully, continuing with WeasyPrint engine"
			else
				log::warn "WeasyPrint installation failed, falling back to XeLaTeX"
				engine="xelatex"
			fi
		else
			log::info "Using XeLaTeX engine as fallback"
			engine="xelatex"
		fi
	fi

	log::info "Selected engine: $engine"

	# Optional: prompt for custom CSS
	if ! read -p "Enter custom CSS file path (optional, press Enter to skip, or 'exit' to quit): " -r css_file; then
		echo "" # Add newline after ^C
		log::info "Exiting interactive mode..."
		exit $EXIT_INTERRUPTED
	fi
	echo

	# Check for exit commands
	if [[ "$css_file" == "exit" || "$css_file" == "quit" || "$css_file" == "q" ]]; then
		log::info "Exiting interactive mode..."
		exit $EXIT_SUCCESS
	fi

	if [[ -n "$css_file" ]]; then
		if ! validate_css_file "$css_file"; then
			log::warn "CSS file validation failed, proceeding without custom CSS"
			css_file=""
		fi
	fi

	# Show summary and confirm
	log::info "=== CONVERSION SUMMARY ==="
	log::info "Input file: $input_file"
	log::info "Output file: $output_file"
	log::info "Theme: $theme"
	if [[ -n "$css_file" ]]; then
		log::info "Custom CSS: $css_file"
	fi
	log::info ""

	if ! read -p "Proceed with conversion? (Y/n): " -n 1 -r; then
		echo "" # Add newline after ^C
		log::info "Exiting interactive mode..."
		exit $EXIT_INTERRUPTED
	fi
	echo

	if [[ $REPLY =~ ^[Nn]$ ]]; then
		log::info "Operation cancelled by user"
		return 1
	fi

	# Perform validation checks
	log::info "Validating input..."

	# Validate file permissions
	validate_file_permissions "$input_file" "$output_file"
	local validation_result=$?
	if [[ $validation_result -ne 0 ]]; then
		return $validation_result
	fi

	# Validate markdown format
	validate_markdown_format "$input_file"
	local format_result=$?
	if [[ $format_result -ne 0 ]]; then
		return $format_result
	fi

	# Check disk space
	check_disk_space "$input_file" "$output_file"
	local disk_result=$?
	if [[ $disk_result -ne 0 ]]; then
		return $disk_result
	fi

	# Perform the conversion
	log::info "Starting conversion..."
	local conversion_result
	conversion_result=$(convert_markdown_to_pdf "$input_file" "$output_file" "false" "$theme" "$css_file" "$engine")
	local conversion_exit=$?

	if [[ $conversion_exit -ne $EXIT_SUCCESS ]]; then
		return $conversion_exit
	fi

	# Validate the result
	if ! validate_conversion_result "$output_file"; then
		log::error "Output validation failed"
		return $EXIT_CONVERSION_FAILED
	fi

	log::success "Interactive conversion completed successfully!"
	log::info "Output saved to: $output_file"

	return $EXIT_SUCCESS
}

main() {
	local quiet=false
	local force=false
	local theme="github"
	local preview=false
	local css_file=""
	local input_file=""
	local output_file=""
	local engine=""

	# Check dependencies first
	if ! check_dependencies; then
		exit $EXIT_DEPENDENCY_MISSING
	fi

	while [[ $# -gt 0 ]]; do
		case $1 in
		--quiet | -q)
			quiet=true
			shift
			;;
		--force | -f)
			force=true
			shift
			;;
		--theme | -t)
			if [[ $# -lt 2 || -z "${2:-}" || "${2:-}" =~ ^- ]]; then
				log::error "Theme name is required after --theme/-t"
				echo "Use --help for usage information."
				exit 1
			fi
			theme="$2"
			shift 2
			;;
		--list-themes | -l)
			list_themes
			exit $EXIT_SUCCESS
			;;
		--preview | -p)
			preview=true
			shift
			;;
		--css | -c)
			if [[ $# -lt 2 || -z "${2:-}" || "${2:-}" =~ ^- ]]; then
				log::error "CSS file path is required after --css/-c"
				echo "Use --help for usage information."
				exit 1
			fi
			css_file="$2"
			shift 2
			;;
		--engine | -e)
			if [[ $# -lt 2 || -z "${2:-}" || "${2:-}" =~ ^- ]]; then
				log::error "Engine name is required after --engine/-e"
				echo "Use --help for usage information."
				exit 1
			fi
			engine="$2"
			shift 2
			;;
		--list-engines)
			list_engines
			exit $EXIT_SUCCESS
			;;
		--update)
			update_to_latest_version
			exit $?
			;;
		--uninstall)
			# Try to use the standalone uninstaller (more robust) first
			if command -v curl >/dev/null 2>&1; then
				log::info "Downloading standalone uninstaller for complete removal..."
				local uninstaller_url="https://raw.githubusercontent.com/jeromecoloma/md-to-pdf/main/uninstall.sh"

				# Test if we can reach the URL first
				if curl -fsSL --connect-timeout 10 --max-time 30 "$uninstaller_url" >/dev/null 2>&1; then
					if bash <(curl -fsSL --connect-timeout 10 --max-time 30 "$uninstaller_url") 2>/dev/null; then
						log::success "Uninstallation completed using standalone uninstaller"
						exit $EXIT_SUCCESS
					else
						log::warn "Standalone uninstaller execution failed, trying built-in fallback..."
					fi
				else
					log::warn "Cannot download standalone uninstaller (network/URL issue), using built-in fallback..."
				fi
			else
				log::info "curl not available, using built-in uninstaller..."
			fi

			# Fallback to built-in uninstaller
			log::info "Using built-in uninstaller..."
			uninstall_md_to_pdf
			;;
		--help | -h | --version | -v)
			parse_common_args "$(basename "$0")" "$@"
			;;
		-*)
			log::error "Unknown option: $1"
			echo "Use --help for usage information."
			exit 1
			;;
		*)
			if [[ -z "$input_file" ]]; then
				input_file="$1"
			elif [[ -z "$output_file" ]]; then
				output_file="$1"
			else
				log::error "Too many arguments"
				echo "Use --help for usage information."
				exit 1
			fi
			shift
			;;
		esac
	done

	# Validate theme
	if ! validate_theme "$theme"; then
		exit 1
	fi

	# Select and validate engine
	local selected_engine
	selected_engine=$(select_engine "$engine")
	local engine_result=$?
	if [[ $engine_result -ne 0 ]]; then
		exit 1
	fi
	engine="$selected_engine"

	# Handle WeasyPrint auto-installation if not available (critical since it's default)
	if [[ "$engine" == "weasyprint" ]] && ! check_weasyprint; then
		if [[ "$quiet" == "false" ]]; then
			log::warn "WeasyPrint is not installed but is the preferred engine for best results."
			if prompt_weasyprint_installation; then
				log::info "Attempting to install WeasyPrint..."
				if install_weasyprint; then
					log::success "WeasyPrint installed successfully, continuing with WeasyPrint engine"
				else
					log::error "WeasyPrint installation failed."
					log::warn "Falling back to XeLaTeX engine. Some features may be limited."
					log::info "To use WeasyPrint later, try: pip3 install weasyprint"
					engine="xelatex"
				fi
			else
				log::info "Installation declined. Using XeLaTeX engine as fallback."
				log::info "Note: XeLaTeX provides good results but may have limited emoji support."
				engine="xelatex"
			fi
		else
			# In quiet mode, attempt installation once, then fallback
			log::info "Attempting quiet WeasyPrint installation..."
			if install_weasyprint >/dev/null 2>&1; then
				log::info "WeasyPrint installed successfully"
			else
				log::info "WeasyPrint installation failed, using XeLaTeX fallback"
				engine="xelatex"
			fi
		fi
	fi

	# Final engine availability check
	if ! engine_available "$engine"; then
		log::error "Selected engine '$engine' is not available"
		log::info "Please install the required dependencies or select a different engine"
		exit $EXIT_DEPENDENCY_MISSING
	fi

	# Validate CSS file if specified
	if ! validate_css_file "$css_file"; then
		exit 1
	fi

	# Check if we should enter interactive mode
	if [[ -z "$input_file" && $# -eq 0 ]]; then
		# No arguments provided, enter interactive mode
		interactive_mode
		exit $?
	fi

	if [[ -z "$input_file" ]]; then
		log::error "Input file is required"
		echo "Use --help for usage information."
		exit 1
	fi

	# Handle preview mode
	if [[ "$preview" == "true" ]]; then
		# Set default output file for preview
		if [[ -z "$output_file" ]]; then
			output_file="${input_file%.*}.pdf"
		fi
		show_preview "$input_file" "$output_file" "$theme" "$css_file" "$engine"
		exit $EXIT_SUCCESS
	fi

	# Set default output file if not specified
	if [[ -z "$output_file" ]]; then
		output_file="${input_file%.*}.pdf"
	fi

	# Check if output file already exists
	if ! check_output_file_exists "$output_file" "$quiet" "$force"; then
		exit $EXIT_SUCCESS # User cancelled, not an error
	fi

	# Validate file permissions and paths
	validate_file_permissions "$input_file" "$output_file"
	local validation_result=$?
	if [[ $validation_result -ne 0 ]]; then
		exit $validation_result
	fi

	# Validate markdown format
	validate_markdown_format "$input_file"
	local format_result=$?
	if [[ $format_result -ne 0 ]]; then
		exit $format_result
	fi

	# Check disk space
	check_disk_space "$input_file" "$output_file"
	local disk_result=$?
	if [[ $disk_result -ne 0 ]]; then
		exit $disk_result
	fi

	# Set global output file for cleanup
	OUTPUT_FILE="$output_file"

	if [[ "$quiet" == "false" ]]; then
		log::info "md-to-pdf tool initialized"
		log::info "Input file: $input_file"
		log::info "Output file: $output_file"
	fi

	# Perform the conversion
	local conversion_result
	conversion_result=$(convert_markdown_to_pdf "$input_file" "$output_file" "$quiet" "$theme" "$css_file" "$engine")
	local conversion_exit=$?

	if [[ $conversion_exit -ne $EXIT_SUCCESS ]]; then
		exit $conversion_exit
	fi

	# Validate the result
	if ! validate_conversion_result "$output_file"; then
		log::error "Output validation failed"
		exit $EXIT_CONVERSION_FAILED
	fi

	if [[ "$quiet" == "false" ]]; then
		log::success "md-to-pdf conversion completed successfully!"
	fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
